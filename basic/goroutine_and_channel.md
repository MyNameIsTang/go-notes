## 协程 (goroutine) 与通道 (channel)

- 作为一门 21 世纪的语言，Go 原生支持应用之间的通信（网络，客户端和服务端，分布式计算和程序的并发。程序可以在不同的处理器和计算机上同时执行不同的代码段。Go 语言为构建并发程序的基本代码块是协程 (goroutine) 与通道 (channel)。他们需要语言，编译器，和 runtime 的支持。Go 语言提供的垃圾回收器对并发编程至关重要。
- 不要通过共享内存来通信，而通过通信来共享内存。
- 通信强制协作。

1. 并发、并行和协程

   1. 什么是协程
      - 一个应用程序是运行在机器上的一个进程；
      - 进程是一个运行在自己内存地址空间里的独立执行体。
      - 一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间的一起工作的执行体。
      - 几乎所有'正式'的程序都是多线程的，以便让用户或计算机不必等待，或者能够同时服务多个请求（如 Web 服务器），或增加性能和吞吐量（例如，通过对不同的数据集并行执行代码）。
      - 一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但是只有同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行。
      - 并行是一种通过使用多处理器以提高速度的能力。所以并发程序可以是并行的，也可以不是。
      - 公认的，使用多线程的应用难以做到准确，最主要的问题是内存中的数据共享，它们会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果（称作竞态）。
      - **不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险**。
      - 解决之道在于同步不同的线程，对数据加锁，这样同时就只有一个线程可以变更数据。在 Go 的标准库 sync 中有一些工具用来在低级别的代码中实现加锁；不过过去的软件开发经验告诉我们这会带来更高的复杂度，更容易使代码出错以及更低的性能，所以这个经典的方法明显不再适合现代多核/多处理器编程：`thread-per-connection` 模型不够有效。
      - Go 更倾向于其他的方式，在诸多比较合适的范式中，有个被称作 `Communicating Sequential Processes`（顺序通信处理）（CSP, C. Hoare 发明的）还有一个叫做 `message passing-model`（消息传递）（已经运用在了其他语言中，比如 Erlang）。
      - 在 Go 中，应用程序并发处理的部分被称作 goroutines（协程），它可以进行更有效的并发运算。在协程和操作系统线程之间并无一对一的关系：协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的；协程调度器在 Go 运行时很好的完成了这个工作。
      - 协程工作在相同的地址空间中，所以共享内存的方式一定是同步的；这个可以使用 sync 包来实现，不过我们很不鼓励这样做：Go 使用 channels 来同步协程。
      - 当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。
      - 协程是轻量的，比线程更轻。它们痕迹非常不明显（使用少量的内存和资源）：使用 4K 的栈内存就可以在堆中创建它们。因为创建非常廉价，必要的时候可以轻松创建并运行大量的协程（在同一个地址空间中 100,000 个连续的协程）。并且它们对栈进行了分割，从而动态的增加（或缩减）内存的使用；栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。
      - 协程可以运行在多个操作系统线程之间，也可以运行在线程之内，可以很小的内存占用就可以处理大量的任务。由于操作系统线程上的协程时间片，可以使用少量的操作系统线程就能拥有任意多个提供服务的协程，而且 Go 运行时可以聪明的意识到哪些协程被阻塞了，暂时搁置它们并处理其他协程。
      - 存在两种并发方式：确定性的（明确定义排序）和非确定性的（加锁/互斥从而未定义排序）。Go 的协程和通道理所当然的支持确定性的并发方式（例如通道具有一个 sender 和一个 receiver）。
      - 协程是通过使用关键字 go 调用（执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）。这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：`go sum(bigArray)`，在后台计算总和。
      - 协程的栈会根据需要进行伸缩，不出现栈溢出；开发者不需要关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数不会得到任何的返回值。
      - 协程的栈会根据需要进行伸缩，不出现栈溢出；开发者不需要关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数不会得到任何的返回值。
      - 任何 Go 程序都必须有的 `main()` 函数也可以看做是一个协程，尽管它并没有通过 go 来启动。协程可以在程序初始化的过程中运行（在 `init()` 函数中）。
      - 在一个协程中，比如需要进行非常密集的运算，可以在运算循环中周期的使用 `runtime.Gosched()`：这会让出处理器，允许运行其他协程；并不会使当前协程挂起，所以会自动恢复执行。使用 `Gosched()` 可以使计算均匀分布，使通信不至于迟迟得不到响应。
   2. 并发和并行的差异
      - Go 的并发原语提供了良好的并发设计基础：表达程序结构以便表示独立地执行的动作；所以 Go 的重点不在于并行的首要位置：并发程序可能是并行的，也可能不是。并行是一种通过使用多处理器以提高速度的能力。但往往是，一个设计良好的并发程序在并行方面的表现也非常出色。
      - 必须使用 GOMAXPROCS 变量。这会告诉运行时有多少个协程同时执行。
      - 并且只有 gc 编译器真正实现了协程，适当的把协程映射到操作系统线程。使用 gccgo 编译器，会为每一个协程创建操作系统线程。
   3. 使用 GOMAXPROCS
      - 在 gc 编译器下（6g 或者 8g）你必须设置 GOMAXPROCS 为一个大于默认值 1 的数值来允许运行时支持使用多于 1 个的操作系统线程，所有的协程都会共享同一个线程除非将 GOMAXPROCS 设置为一个大于 1 的数。
      - 当 GOMAXPROCS 大于 1 时，会有一个线程池管理许多的线程。
      - 通过 gccgo 编译器 GOMAXPROCS 有效的与运行中的协程数量相等。
      - 假设 n 是机器上处理器或者核心的数量。如果你设置环境变量 `GOMAXPROCS>=n`，或者执行 `runtime.GOMAXPROCS(n)`，接下来协程会被分割（分散）到 n 个处理器上。更多的处理器并不意味着性能的线性提升。
      - 有这样一个经验法则，对于 n 个核心的情况设置 GOMAXPROCS 为 n-1 以获得最佳性能，也同样需要遵守这条规则：协程的数量 > 1 + GOMAXPROCS > 1。
      - 所以如果在某一时间只有一个协程在执行，不要设置 GOMAXPROCS！
      - 还有一些通过实验观察到的现象：在一台 1 颗 CPU 的笔记本电脑上，增加 GOMAXPROCS 到 9 会带来性能提升。在一台 32 核的机器上，设置 `GOMAXPROCS=8` 会达到最好的性能，在测试环境中，更高的数值无法提升性能。如果设置一个很大的 GOMAXPROCS 只会带来轻微的性能下降；设置 `GOMAXPROCS=100`，使用 top 命令和 H 选项查看到只有 7 个活动的线程。
      - 增加 GOMAXPROCS 的数值对程序进行并发计算是有好处的；
      - GOMAXPROCS 等同于（并发的）线程数量，在一台核心数多于 1 个的机器上，会尽可能有等同于核心数的线程在并行运行。
   4. 如何用命令行指定使用的核心数量
      - 使用 flags 包，如下：`var numCores = flag.Int("n", 2, "number of CPU cores to use")`。
      - 在 `main()` 中：
        ```
           flag.Parse()
           runtime.GOMAXPROCS(*numCores)
        ```
      - 协程可以通过调用 `runtime.Goexit()` 来停止，尽管这样做几乎没有必要。
      - 当 `main()` 函数返回的时候，程序退出：它不会等待任何其他非 main 协程的结束。这就是为什么在服务器程序中，每一个请求都会启动一个协程来处理，`server()` 函数必须保持运行状态。通常使用一个无限循环来达到这样的目的。
      - 另外，协程是独立的处理单元，一旦陆续启动一些协程，你无法确定他们是什么时候真正开始执行的。你的代码逻辑必须独立于协程调用的顺序。
      - 协程更有用的一个例子应该是在一个非常长的数组中查找一个元素。将数组分割为若干个不重复的切片，然后给每一个切片启动一个协程进行查找计算。这样许多并行的协程可以用来进行查找任务，整体的查找时间会缩短（除以协程的数量）。
   5. Go 协程 (goroutines) 和协程 (coroutines)
      - 在其他语言中，比如 C#，Lua 或者 Python 都有协程的概念。这个名字表明它和 Go 协程有些相似，不过有两点不同：
        - Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的。
        - Go 协程通过通道来通信；协程通过让出和恢复操作来通信。
      - Go 协程比协程更强大，也很容易从协程的逻辑复用到 Go 协程。

2. 协程间的信道

   1. 概念
      - 协程可以使用共享变量来通信，但是很不提倡这样做，因为这种方式给所有的共享内存的多线程都带来了困难。
      - Go 有一种特殊的类型，通道（channel），就像一个可以用于发送类型化数据的管道，由其负责协程之间的通信，从而避开所有由共享内存导致的陷阱；这种通过通道进行通信的方式保证了同步性。
      - 数据在通道中进行传递：**在任何给定时间，一个数据被设计为只有一个协程可以对其访问，所以不会发生数据竞争**。 数据的所有权（可以读写数据的能力）也因此被传递。
      - 通道服务于通信的两个目的：值的交换，同步的，保证了两个计算（协程）任何时候都是可知状态。
      - 通常使用这样的格式来声明通道：`var identifier chan datatype`。
      - 未初始化的通道的值是 nil。
      - 所以通道只能传输一种类型的数据，比如 `chan int` 或者 `chan string`，所有的类型都可以用于通道，空接口 `interface{}` 也可以，甚至可以（有时非常有用）创建通道的通道。
      - 通道实际上是类型化消息的队列：使数据得以传输。它是先进先出(FIFO) 的结构所以可以保证发送给他们的元素的顺序（通道可以比作 Unix shells 中的双向管道 (two-way pipe)）。通道也是引用类型，所以我们使用 `make()` 函数来给它分配内存：`ch1 := make(chan string)`。
      - 构建一个 int 通道的通道： `chanOfChans := make(chan chan int)`。
      - 函数通道：`funcChan := make(chan func())`。
      - 所以通道是第一类对象：可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送它们自身。另外它们是类型化的，允许类型检查，比如尝试使用整数通道发送一个指针。
   2. 通信操作符 <-
      - 这个操作符直观的标示了数据的传输：信息按照箭头的方向流动。
      - 流向通道（发送），`ch <- int1` 表示：用通道 ch 发送变量 int1（双目运算符，中缀 = 发送）
      - 从通道流出（接收），三种方式：
        - `int2 = <- ch` 表示：变量 int2 从通道 ch（一元运算的前缀操作符，前缀 = 接收）接收数据（获取新值）
        - `<- ch` 可以单独调用获取通道的（下一个）值，当前值会被丢弃，但是可以用来验证，所以以下代码是合法的：
          ```
            if <- ch != 1000{
                ...
             }
          ```
        - 同一个操作符 <- 既用于发送也用于接收，但 Go 会根据操作对象弄明白该干什么 。
      - 虽非强制要求，但为了可读性通道的命名通常以 ch 开头或者包含 chan 。通道的发送和接收都是原子操作：它们总是互不干扰地完成。
      - 运行时 (runtime) 会检查所有的协程是否在等待着什么东西（可从某个通道读取或者写入某个通道），这意味着程序将无法继续执行。这是死锁 (deadlock) 的一种形式，而运行时 (runtime) 可以为我们检测到这种情况。
      - 不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。
   3. 通道阻塞
      - 默认情况下，通信是同步且无缓冲的：在有接受者接收数据之前，发送不会结束。
      - 可以想象一个无缓冲的通道在没有空间来保存数据的时候：必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。所以通道的发送/接收操作在对方准备好之前是阻塞的：
        - 对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果 ch 中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。
        - 对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。
   4. 通过一个（或多个）通道交换数据进行协程同步。
      - 通信是一种同步形式：通过通道，两个协程在通信（协程会合）中某刻同步交换数据。无缓冲通道成为了多个协程同步的完美工具。
      - 甚至可以在通道两端互相阻塞对方，形成了叫做死锁的状态。Go 运行时会检查并 `panic()`，停止程序。死锁几乎完全是由糟糕的设计导致的。
      - 无缓冲通道会被阻塞。设计无阻塞的程序可以避免这种情况，或者使用带缓冲的通道。
   5. 同步通道-使用带缓冲的通道
      - 一个无缓冲通道只能包含 1 个元素，有时显得很局限。给通道提供了一个缓存，可以在扩展的 make 命令中设置它的容量，如下：`ch1 := make(chan string, 100)`，第二个参数是通道可以同时容纳的元素（这里是 string）个数。
      - 在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。
      - 缓冲容量和类型无关，所以可以（尽管可能导致危险）给一些通道设置不同的容量，只要他们拥有同样的元素类型。内置的 `cap()` 函数可以返回缓冲区的容量。
      - 如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。如果容量是 0 或者未设置，通信仅在收发双方准备好的情况下才可以成功。
      - 同步：ch :=make(chan type, value)
        - `value == 0 -> synchronous`, unbuffered （阻塞）
        - `value > 0 -> asynchronous`, buffered（非阻塞）取决于 value 元素
      - 若使用通道的缓冲，你的程序会在“请求”激增的时候表现更好：更具弹性，专业术语叫：更具有伸缩性(scalable)。在设计算法时首先考虑使用无缓冲通道，只在不确定的情况下使用缓冲。
   6. 协程中用通道输出结果
      - 为了知道计算何时完成，可以通过信道回报。例：
        ```
           ch := make(chan int)
           go sum(bigArray, ch)
           sum := <-ch
        ```
      - 也可以使用通道来达到同步的目的，这个很有效的用法在传统计算机中称为信号量 (semaphore)。或者换个方式：通过通道发送信号告知处理已经完成（在协程中）。
      - 在其他协程运行时让 main 程序无限阻塞的通常做法是在 `main()` 函数的最后放置一个 `select {}`。
      - 也可以使用通道让 main 程序等待协程完成，就是所谓的信号量模式。
   7. 信号量模式

      - 协程通过在通道 ch 中放置一个值来处理结束的信号。`main()` 协程等待 `<-ch` 直到从中获取到值。
      - 期望从这个通道中获取返回的结果，像这样：

        ```
           func compute(ch chan int){
              ch <- someComputation() // when it completes, signal on the channel.
           }

           func main(){
              ch := make(chan int) 	// allocate a channel.
              go compute(ch)		// start something in a goroutines
              doSomethingElseForAWhile()
              result := <- ch
           }
        ```

      - 这个信号也可以是其他的，不返回结果，比如下面这个协程中的匿名函数 (lambda) 协程：
        ```
           ch := make(chan int)
           go func(){
              // doSomething
              ch <- 1 // Send a signal; value does not matter
           }()
           doSomethingElseForAWhile()
           <- ch	// Wait for goroutine to finish; discard sent value.
        ```
      - 或者等待两个协程完成，每一个都会对切片 s 的一部分进行排序，片段如下：
        ```
            done := make(chan bool)
            // doSort is a lambda function, so a closure which knows the channel done:
            doSort := func(s []int){
               sort(s)
               done <- true
            }
            i := pivot(s)
            go doSort(s[:i])
            go doSort(s[i:])
            <-done
            <-done
        ```
      - 用完整的信号量模式对长度为 N 的 float64 切片进行了 N 个 `doSomething()` 计算并同时完成，通道 sem 分配了相同的长度（且包含空接口类型的元素），待所有的计算都完成后，发送信号（通过放入值）。在循环中从通道 sem 不停的接收数据来等待所有的协程完成。
        ```
           type Empty interface {}
           var empty Empty
           ...
           data := make([]float64, N)
           res := make([]float64, N)
           sem := make(chan Empty, N)
           ...
           for i, xi := range data {
              go func (i int, xi float64) {
                 res[i] = doSomething(i, xi)
                 sem <- empty
              } (i, xi)
           }
           // wait for goroutines to finish
           for i := 0; i < N; i++ { <-sem }
        ```

   8. 实现并行的 for 循环
      - for 循环的每一个迭代是并行完成的：
        ```
           for i, v := range data {
              go func (i int, v float64) {
                 doSomething(i, v)
                 ...
              } (i, v)
           }
        ```
      - 在 for 循环中并行计算迭代可能带来很好的性能提升。不过所有的迭代都必须是独立完成的。
   9. 用带缓冲通道实现一个信号量

      - 信号量是实现互斥锁（排外锁）常见的同步机制，限制对资源的访问，解决读写问题，比如没有实现信号量的 sync 的 Go 包，使用带缓冲的通道可以轻松实现：
        - 带缓冲通道的容量和要同步的资源容量相同
        - 通道的长度（当前存放的元素个数）与当前资源被使用的数量相同
        - 容量减去通道的长度就是未处理的资源个数（标准信号量的整数值）
      - 不用管通道中存放的是什么，只关注长度；因此我们创建了一个长度可变但容量为 0（字节）的通道：
        ```
           type Empty interface {}
           type semaphore chan Empty
        ```
      - 将可用资源的数量 N 来初始化信号量 `semaphore：sem = make(semaphore, N)`
      - 然后直接对信号量进行操作：

        ```
           // acquire n resources
           func (s semaphore) P(n int) {
              e := new(Empty)
              for i := 0; i < n; i++ {
                 s <- e
              }
           }

           // release n resources
           func (s semaphore) V(n int) {
              for i:= 0; i < n; i++{
                 <- s
              }
           }
        ```

      - 可以用来实现一个互斥的例子：

        ```
           /* mutexes */
           func (s semaphore) Lock() {
              s.P(1)
           }

           func (s semaphore) Unlock(){
              s.V(1)
           }

           /* signal-wait */
           func (s semaphore) Wait(n int) {
              s.P(n)
           }

           func (s semaphore) Signal() {
              s.V(1)
           }
        ```

      - **习惯用法：通道工厂模式**
        - 编程中常见的另外一种模式如下：不将通道作为参数传递给协程，而用函数来生成一个通道并返回（工厂角色）；函数内有个匿名函数被协程调用。
        ```
            func pump() chan int {
               ch := make(chan int)
               go func() {
                  for i := 0; ; i++ {
                     ch <- i
                  }
               }()
               return ch
            }
        ```

   10. 给通道使用 for 循环

       - for 循环的 range 语句可以用在通道 ch 上，便可以从通道中获取值，像这样：

         ```
            for v := range ch {
               fmt.Printf("The value is %v\n", v)
            }
         ```

       - 它从指定通道中读取数据直到通道关闭，才继续执行下边的代码。很明显，另外一个协程必须写入 ch（不然代码就阻塞在 for 循环了），而且必须在写入完成后才关闭。

         ```
            func suck(ch chan int) {
               go func() {
                  for v := range ch {
                     fmt.Println(v)
                  }
               }()
            }
         ```

       - **习惯用法：通道迭代器模式**
         - 通常，需要从包含了地址索引字段 items 的容器给通道填入元素。为容器的类型定义一个方法 `Iter()`，返回一个只读的通道 items：
           ```
              func (c *container) Iter () <- chan item {
                 ch := make(chan item)
                 go func () {
                    for i:= 0; i < c.Len(); i++{	// or use a for-range loop
                       ch <- c.items[i]
                    }
                 } ()
                 return ch
              }
           ```
         - 在协程里，一个 for 循环迭代容器 c 中的元素（对于树或图的算法，这种简单的 for 循环可以替换为深度优先搜索）。
         - 调用这个方法的代码可以这样迭代容器：`for x := range container.Iter() { ... }`。
         - 其运行在自己启动的协程中，所以上边的迭代用到了一个通道和两个协程（可能运行在不同的线程上）。 这样我们就有了一个典型的生产者-消费者模式。
         - 如果在程序结束之前，向通道写值的协程未完成工作，则这个协程不会被垃圾回收；这是设计使然。这种看起来并不符合预期的行为正是由通道这种线程安全的通信方式所导致的。如此一来，一个协程为了写入一个永远无人读取的通道而被挂起就成了一个 bug ，而并非预想中的那样被悄悄回收掉 (garbage-collected) 了。
       - **习惯用法：生产者消费者模式**
         - 假设有 Produce() 函数来产生 Consume() 函数需要的值。它们都可以运行在独立的协程中，生产者在通道中放入给消费者读取的值。整个处理过程可以替换为无限循环：
           ```
              for {
                 Consume(Produce())
              }
           ```

   11. 通道的方向

       - 通道类型可以用注解来表示它只发送或者只接收：
         - 只能发送：`var send_only chan<- int`
         - 只能接收：`var recv_only <-chan int`
       - 只接收的通道 (`<-chan T`) 无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。
       - 通道创建的时候都是双向的，但也可以分配给有方向的通道变量：

         ```
            var c = make(chan int) // bidirectional
            go source(c)
            go sink(c)

            func source(ch chan<- int){
               for { ch <- 1 }
            }

            func sink(ch <-chan int) {
               for { <-ch }
            }
         ```

       - **习惯用法：管道和选择器模式**

         - 协程处理它从通道接收的数据并发送给输出通道：

           ```
              sendChan := make(chan int)
              receiveChan := make(chan string)
              go processChannel(sendChan, receiveChan)

              func processChannel(in <-chan int, out chan<- string) {
                 for inValue := range in {
                    result := ... /// processing inValue
                    out <- result
                 }
              }
           ```

         - 通过使用方向注解来限制协程对通道的操作。
         
