## 函数(function)

函数是 Go 里面的基本代码块：Go 函数的功能非常强大，以至于被认为拥有函数式编程语言的多种特性。

1.  介绍

    - 每一个程序都包含很多的函数：函数是基本的代码块。
    - Go 是编译型语言，所以函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。
    - 编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务（那就是函数）来解决。而且，同一个任务（函数）可以被调用多次，有助于代码重用。
    - 当函数执行到代码块最后一行（} 之前）或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数；这些参数将作为返回值供调用者使用。简单的 return 语句也可以用来结束 for 死循环，或者结束一个协程 (goroutine)。
    - Go 里面有三种类型的函数：
      - 普通的带有名字的函数
      - 匿名函数或者 lambda 函数
      - 方法（Methods）
    - 除了 main()、init() 函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为函数签名。
    - 函数可以将其他函数调用作为它的参数，只要这个被调用函数的返回值个数、返回值类型和返回值的顺序与调用函数所需求的实参是一致的，例如：`f1(f2(a, b))`。
    - 如果需要申明一个在外部定义的函数，你只需要给出函数名与函数签名，不需要给出函数体：`func flushICache(begin, end uintptr) // implemented externally`。
    - 函数也可以以申明的方式被使用，作为一个函数类型，就像：`type binOp func(int, int) int`。
    - 函数是一等值 (first-class value)：它们可以赋值给变量，就像 `add := binOp` 一样。
    - 函数值 (functions value) 之间可以相互比较：如果它们引用的是相同的函数或者都是 nil 的话，则认为它们是相同的函数。函数不能在其它函数里面声明（不能嵌套），不过我们可以通过使用匿名函数来破除这个限制。
    - 目前 Go 没有泛型 (generic) 的概念，也就是说它不支持那种支持多种类型的函数。不过在大部分情况下可以通过接口 (interface)，特别是空接口与类型选择（type switch）与/或者通过使用反射（reflection）来实现相似的功能。

2.  函数参数与返回值

    - 函数能够接收参数供自己使用，也可以返回零个或多个值（我们通常把返回多个值称为返回一组值）。相比与 C、C++、Java 和 C#，多值返回是 Go 的一大特性，为我们判断一个函数是否正常执行提供了方便。
    - 通过 return 关键字返回一组值。事实上，任何一个有返回值（单个或多个）的函数都必须以 return 或 panic 结尾。
    - 在函数块里面，return 之后的语句都不会执行。如果一个函数需要返回值，那么这个函数里面的每一个代码分支 (code-path) 都要有 return 语句。
    - 函数定义时，它的形参一般是有名字的，不过我们也可以定义没有形参名的函数，只有相应的形参类型，就像这样：`func f(int, int, float64)`。
    - 没有参数的函数通常被称为 niladic 函数 (niladic function)，就像 `main.main()`。

    1. 按值传递（call by value）按引用传递（call by reference）
       - Go 默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量，比如 `Function(arg1)`。
       - 希望函数可以直接修改参数的值，而不是对参数的副本进行操作，需要将参数的地址（变量名前面添加 & 符号，比如 &variable）传递给函数，这就是按引用传递，比如 `Function(&arg1)`，此时传递给函数的是一个指针。
       - 如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制；我们可以通过这个指针的值来修改这个值所指向的地址上的值。
       - 指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递。
       - 几乎在任何情况下，传递指针（一个 32 位或者 64 位的值）的消耗都比传递副本来得少。
       - 在函数调用时，像切片 (slice)、字典 (map)、接口 (interface)、通道 (channel) 这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。
       - 有些函数只是完成一个任务，并没有返回值。仅仅是利用了这种函数的副作用 (side-effect)，就像输出文本到终端，发送一个邮件或者是记录一个错误等。但是绝大部分的函数还是带有返回值的。
       - 如果一个函数需要返回四到五个值，我们可以传递一个切片给函数（如果返回值具有相同类型）或者是传递一个结构体（如果返回值具有不同的类型）。因为传递一个指针允许直接修改变量的值，消耗也更少。
    2. 命名的返回（named return variables）
       - 当需要返回多个非命名返回值时，需要使用 () 把它们括起来，比如 `(int, int)`。
       - 命名返回值作为结果形参 (result parameters) 被初始化为相应类型的零值，当需要返回的时候，我们只需要一条简单的不带参数的 return 语句。
       - 需要注意的是，即使只有一个命名返回值，也需要使用 () 括起来
         ```
            func getX2AndX3_2(input int) (x2, x3 int) {
               x2 = input * 2
               x3 = input * 3
               return
            }
         ```
       - 即使函数使用了命名返回值，你依旧可以无视它而返回明确的值。
       - 任何一个非命名返回值（使用非命名返回值是很糟的编程习惯）在 return 语句里面都要明确指出包含返回值的变量或是一个可计算的值（就像上面警告所指出的那样）。
       - 尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。
    3. 空白符（blank identifier）
       - 空白符用来匹配一些不需要的值，然后丢弃掉：`a, _ = func()`
    4. 改变外部变量（outside variable）
       - 传递指针给函数不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 return 返回。
         ```
            func Multiply(a, b int, reply *int) {
               *reply = a + b
            }
         ```
       - 然而，如果不小心使用的话，传递一个指针很容易引发一些不确定的事，所以，我们要十分小心那些可以改变外部变量的函数，在必要时，需要添加注释以便其他人能够更加清楚的知道函数里面到底发生了什么。

3.  传递变长参数

    - 如果函数的最后一个参数是采用 ...type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变参函数。例如：`func myFunc(a, b, arg ...int) {}`。
    - 函数接受一个类似于切片 (slice) 的参数，该参数可以通过 for 循环结构迭代。
    - 如果参数被存储在一个 slice 类型的变量 slice 中，则可以通过 `slice...` 的形式来传递参数，调用变参函数。
    - 一个接受变长参数的函数可以将这个参数作为其它函数的参数进行传递：

      ```
         func F1(s ...string) {
            F2(s...)
            F3(s)
         }

         func F2(s ...string) { }
         func F3(s []string) { }
      ```

    - 变长参数可以作为对应类型的 slice 进行二次传递。
    - 但是如果变长参数的类型并不是都相同的呢？解决方法：

      - 使用结构

        ```
           type Options struct {
              par1 type1,
              par2 type2,
              ...
           }

        ```

        - TODO:函数 F1() 可以使用正常的参数 a 和 b，以及一个没有任何初始化的 Options 结构： F1(a, b, Options {})。如果需要对选项进行初始化，则可以使用 F1(a, b, Options {par1:val1, par2:val2})。

      - 使用空接口
        - 如果一个变长参数的类型没有被指定，则可以使用默认的空接口 interface{}，这样就可以接受任何类型的参数。
        - 不仅可以用于长度未知的参数，还可以用于任何不确定类型的参数。
        - 一般而言我们会使用一个 for-range 循环以及 switch 结构对每个参数的类型进行判断：
          ```
             func typecheck(..,..,values … interface{}) {
                for _, value := range values {
                   switch v := value.(type) {
                      case int: …
                      case float: …
                      case string: …
                      case bool: …
                      default: …
                   }
                }
             }
          ```
