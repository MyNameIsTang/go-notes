## 结构 (struct) 与方法 (method)

- Go 通过类型别名 (alias types) 和结构体的形式支持用户自定义类型，或者叫定制类型。
- 一个带属性的结构体试图表示一个现实世界中的实体。
- 结构体是复合类型 (composite types)，当需要定义一个类型，它由一系列属性组成，每个属性都有自己的类型和值的时候，就应该使用结构体，它把数据聚集在一起。然后可以访问这些数据，就好像它是一个独立实体的一部分。结构体也是值类型，因此可以通过 new 函数来创建。
- 组成结构体类型的那些数据称为 字段 (fields)。每个字段都有一个类型和一个名字；在一个结构体中，字段名字必须是唯一的。
- 结构体的概念在软件工程上旧的术语叫 ADT（抽象数据类型：Abstract Data Type），在一些老的编程语言中叫 记录 (Record)，比如 Cobol，在 C 家族的编程语言中它也存在，并且名字也是 struct，在面向对象的编程语言中，跟一个无方法的轻量级类一样。不过因为 Go 语言中没有类的概念，因此在 Go 中结构体有着更为重要的地位。

1. 结构体定义

   - 结构体定义的一般方式如下：
     ```
       type identifier struct {
          field1 type1
          field2 type2
          ...
       }
     ```
   - `type T struct {a, b int}` 也是合法的语法，它更适用于简单的结构体。
   - 结构体里的字段都有 名字，像 `field1、field2` 等，如果字段在代码中从来也不会被用到，那么可以命名它为 \_。
   - 结构体的字段可以是任何类型，甚至是结构体本身，也可以是函数或者接口。可以声明结构体类型的一个变量，然后像下面这样给它的字段赋值：
     ```
       var s T
       s.a = 5
       s.b = 8
     ```
   - 数组可以看作是一种结构体类型，不过它使用下标而不是具名的字段。
   - 使用 `new()`
     - 使用 `new()` 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：`var t *T = new(T)`，如果需要可以把这条语句放在不同的行（比如定义是包范围的，但是分配却没有必要在开始就做）。
     - 写这条语句的惯用方法是：`t := new(T)`，变量 t 是一个指向 T 的指针，此时结构体字段的值是它们所属类型的零值。
     - 声明 `var t T` 也会给 t 分配内存，并零值化内存，但是这个时候 t 是类型 T 。在这两种方式中，t 通常被称做类型 T 的一个实例 (instance) 或对象 (object)。
     - 就像在面向对象语言所作的那样，可以使用点号符给字段赋值：`structname.fieldname = value`。
     - 同样的，使用点号符可以获取结构体字段的值：`structname.fieldname`。
     - 在 Go 语言中这叫 选择器 (selector)。无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的 选择器符 (selector-notation) 来引用结构体的字段
     - 初始化一个结构体实例（一个结构体字面量：struct-literal）的更简短和惯用的方式如下：` ms := &struct1{10, 15.5, "Chris"}`，或者：`var ms struct1; ms = struct1{10, 15.5, "Chris"}`。
     - 混合字面量语法 (composite literal syntax) `&struct1{a, b, c}` 是一种简写，底层仍然会调用 `new()`，这里值的顺序必须按照字段顺序来写。表达式 `new(Type)` 和 `&Type{}` 是等价的。
     - 结构体类型和字段的命名遵循可见性规则，一个导出的结构体类型中有些字段是导出的，另一些不是，这是可能的。
     - 下图说明了结构体类型实例和一个指向它的指针的内存布局：`type Point struct { x, y int }`
       - 使用 new() 初始化：
         ![new](./image/struct_new.png)
       - 作为结构体字面量初始化：
         ![Alt text](./image/struct_literal.png)
   - 结构体的内存布局
     - Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。
     - Go 语言中的指针：
       ```
         type Rect1 struct {Min, Max Point }
         type Rect2 struct {Min, Max *Point }
       ```
       ![Alt text](./image/struct_pointer.png)
     - 递归结构体，结构体类型可以通过引用自身来定义。这在定义链表或二叉树的元素（通常叫节点）时特别有用，此时节点包含指向临近节点的链接（地址）。
       - 链表
         ![Alt text](./image/struct_list.png)
         - Go 代码：
           ```
             type Node struct {
               data    float64
               su      *Node
             }
           ```
         - 链表中的第一个元素叫 head，它指向第二个元素；最后一个元素叫 tail，它没有后继元素，所以它的 su 为 nil 值。当然真实的链接会有很多数据节点，并且链表可以动态增长或收缩。
         - 可以定义一个双向链表，它有一个前趋节点 pr 和一个后继节点 su：
           ```
             type Node struct {
               pr      *Node
               data    float64
               su      *Node
             }
           ```
       - 二叉树
         ![Alt text](./image/struct_binary_tree.png)
         - 二叉树中每个节点最多能链接至两个节点：左节点 (le) 和右节点 (ri)，这两个节点本身又可以有左右节点，依次类推。树的顶层节点叫根节点 (root)，底层没有子节点的节点叫叶子节点 (leaves)，叶子节点的 le 和 ri 指针为 nil 值。
         ```
          type Tree struct {
            le      *Tree
            data    float64
            ri      *Tree
          }
         ```
     - 结构体转换
       - Go 中的类型转换遵循严格的规则。当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型，同时需要注意其中非法赋值或转换引起的编译错误。

2. 使用工厂方法创建结构体实例

   1. 结构体工厂

      - Go 语言不支持面向对象编程语言中那样的构造子方法，但是可以很容易的在 Go 中实现 “构造子工厂”方法。
      - 为了方便通常会为类型定义一个工厂，按惯例，工厂的名字以 new... 或 New... 开头。假设定义了如下的 File 结构体类型：
        ```
          type File struct {
            fd      int     // 文件描述符
            name    string  // 文件名
          }
        ```
      - 下面是这个结构体类型对应的工厂方法，它返回一个指向结构体实例的指针：

        ```
          func NewFile(fd int, name string) *File {
            if fd < 0 {
                return nil
            }

            return &File{fd, name}
          }

          f := NewFile(10, "./test.txt")
        ```

      - 在 Go 语言中常常像上面这样在工厂方法里使用初始化来简便的实现构造函数。
      - 如果 File 是一个结构体类型，那么表达式 `new(File)` 和 `&File{}` 是等价的。
      - 如果想知道结构体类型 T 的一个实例占用了多少内存，可以使用：`size := unsafe.Sizeof(T{})`。
      - 如何强制使用工厂方法

        - 通过应用可见性规则就可以禁止使用 `new()` 函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样。

          ```
            type matrix struct {
                ...
            }

            func NewMatrix(params) *matrix {
              m := new(matrix) // 初始化 m
              return m
            }
          ```

        - 在其他包里使用工厂方法：
          ```
            package main
            import "matrix"
            ...
            wrong := new(matrix.matrix)     // 编译失败（matrix 是私有的）
            right := matrix.NewMatrix(...)  // 实例化 matrix 的唯一方式
          ```

   2. map 和 struct vs new() 和 make()
      - 只能使用 `make()` 的三种类型：slices 、 maps 、 channels。
      - 试图 `make()` 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 `new()` 一个 map 并试图向其填充数据，将会引发运行时错误！ 因为 `new(Foo)` 返回的是一个指向 nil 的指针，它尚未被分配内存。所以在使用 map 时要特别谨慎。

3. 带标签的结构体

   - 结构体中的字段除了有名字和类型外，还可以有一个可选的标签 (tag)：它是一个附属于字段的字符串，可以是文档或其他的重要标记。
   - 标签的内容不可以在一般的编程中使用，只有包 reflect 能获取它。

     ```
       type TagType struct { // tags
         field1 bool   "An important answer"
         field2 string "The name of the thing"
         field3 int    "How much there are"
       }

       func refTag(tt TagType, ix int) {
          ttType := reflect.TypeOf(tt)
          ixField := ttType.Field(ix)
          fmt.Printf("%v\n", ixField.Tag)
        }
     ```

4. 匿名字段和内嵌结构体

   1. 定义

      - 结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。
      - 匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体。
      - 可以粗略地将这个和面向对象语言中的继承概念相比较，随后将会看到它被用来模拟类似继承的行为。Go 语言中的继承是通过内嵌或组合来实现的，所以可以说，在 Go 语言中，相比较于继承，组合更受青睐。

        ```
          type innerS struct {
            in1 int
            in2 int
          }

          type outerS struct {
            b    int
            c    float32
            int  // anonymous field
            innerS //anonymous field
          }
        ```

      - 通过类型 outer.int 的名字来获取存储在匿名字段中的数据，于是可以得出一个结论：在一个结构体中对于每一种数据类型只能有一个匿名字段。

   2. 内嵌结构体

      - 同样地结构体也是一种数据类型，所以它也可以作为一个匿名字段来使用，如同上面例子中那样。外层结构体通过 outer.in1 直接进入内层结构体的字段，内嵌结构体甚至可以来自其他包。内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。

   3. 命名冲突
      - 当两个字段拥有相同的名字（可能是继承来的名字）时该怎么办呢？
        - 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；
        - 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。

5. 方法

   1. 方法定义
      - 在 Go 语言中，结构体就像是类的一种简化形式，在 Go 中有一个概念，它和方法有着同样的名字，并且大体上意思相同：Go 方法是作用在接收者 (receiver) 上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。
      - 接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：invalid receiver type...。
      - 最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。
      - 一个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：**它们必须是同一个包的**。
      - 类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集 (method set)。
      - 因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：
        ```
          func (a *denseMatrix) Add(b Matrix) Matrix
          func (a *sparseMatrix) Add(b Matrix) Matrix
        ```
      - 别名类型没有原始类型上已经定义过的方法。
      - 或者将别的包中的类型作为匿名类型嵌入在一个新的结构体中。当然方法只在这个别名类型上有效。
      - 定义方法的一般格式如下：`func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... }`
        - 在方法名之前，func 关键字之后的括号中指定 receiver。
        - 如果 recv 是 receiver 的实例，Method1 是它的方法名，那么方法调用遵循传统的 `object.name` 选择器符号：`recv.Method1()`。
        - 如果 recv 是一个指针，Go 会自动解引用。
        - 如果方法不需要使用 recv 的值，可以用 _ 替换它，比如：`func (_ receiver_type) methodName(parameter_list) (return_value_list) { ... }`。
        - recv 就像是面向对象语言中的 this 或 self，但是 Go 中并没有这两个关键字。随个人喜好，可以使用 this 或 self 作为 receiver 的名字。
   2. 函数和方法的区别
      - 函数将变量作为参数：`Function1(recv)`
      - 方法在变量上被调用：`recv.Method1()`
      - 在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。
      - 不要忘记 `Method1()` 后边的括号 ()，否则会引发编译器错误：method recv.Method1 is not an expression, must be called。
      - 接收者必须有一个显式的名字，这个名字必须在方法中被使用。
      - receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。
      - 在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。
      - 方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。
   3. 指针或值作为接收者
      - 鉴于性能的原因，recv 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。
      - 如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。
      - 在值和指针上调用方法：
        - 可以有连接到类型的方法，也可以有连接到类型指针的方法。
        - 但是这没关系：对于类型 T，如果在 `*T` 上存在方法 `Meth()`，并且 t 是这个类型的变量，那么 `t.Meth()` 会被自动转换为 `(&t).Meth()`。
        - 指针方法和值方法都可以在指针或非指针上被调用。
   4. 方法和未导出字段

      - 该如何在另一个程序中修改或者只是读取一个 Person 的名字呢？
      - 这可以通过面向对象语言一个众所周知的技术来完成：提供 `getter()` 和 `setter()` 方法。对于 `setter()` 方法使用 `Set...` 前缀，对于 `getter()` 方法只使用成员名。

        ```
          type Person struct {
            firstName string
            lastName  string
          }

          func (p *Person) FirstName() string {
            return p.firstName
          }

          func (p *Person) SetFirstName(newName string) {
            p.firstName = newName
          }
        ```

      - 并发访问对象
        - 对象的字段（属性）不应该由 2 个或 2 个以上的不同线程在同一时间去改变。如果在程序发生这种情况，为了安全并发访问，可以使用包 sync（也可以通过 goroutines 和 channels 实现）。

   5. 内嵌类型的方法和继承
      - 当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 继承 了这些方法：将父类型放在子类型中来实现亚型。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果，也类似 Ruby 中的混入 (mixin)。
      - 内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法“晋升”成为了外层类型的方法。当然类型可以有只作用于本身实例而不作用于内嵌“父”类型上的方法。
      - 可以覆写方法（像字段一样）：和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。
      - 因为一个结构体可以嵌入多个匿名类型，所以实际上我们可以有一个简单版本的多重继承，就像：`type Child struct { Father; Mother}`。
      - 结构体内嵌和自己在同一个包中的结构体时，可以彼此访问对方所有的字段和方法。
   6. 如何在类型中嵌入功能
      - 主要有两种方法来实现在类型中嵌入功能：
        - A：聚合（或组合）：包含一个所需功能类型的具名字段。
        - B：内嵌：内嵌（匿名地）所需功能类型。
      - 内嵌的类型不需要指针。
      - 如果内嵌类型嵌入了其他类型，也是可以的，那些类型的方法可以直接在外层类型中使用。
      - 因此一个好的策略是创建一些小的、可复用的类型作为一个工具箱，用于组成域类型。
   7. 多重继承
      - 多重继承指的是类型获得多个父类型行为的能力，它在传统的面向对象语言中通常是不被实现的（C++ 和 Python 例外）。
      - 因为在类继承层次中，多重继承会给编译器引入额外的复杂度。但是在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。
   8. 通用方法和方法命名
      - 在编程中一些基本操作会一遍又一遍的出现，比如打开 (Open)、关闭 (Close)、读 (Read)、写 (Write)、排序(Sort) 等等，并且它们都有一个大致的意思：打开 (Open)可以作用于一个文件、一个网络连接、一个数据库连接等等。
      - 具体的实现可能千差万别，但是基本的概念是一致的。
      - 在 Go 语言中，通过使用接口，标准库广泛的应用了这些规则，在标准库中这些通用方法都有一致的名字，比如 Open()、Read()、Write()等。
      - 想写规范的 Go 程序，就应该遵守这些约定，给方法合适的名字和签名，就像那些通用方法那样。这样做会使 Go 开发的软件更加具有一致性和可读性。比如：如果需要一个 `convert-to-string()` 方法，应该命名为 `String()`，而不是 `ToString()`。
   9. 和其他面向对象语言比较 Go 的类型和方法
      - 在如 C++、Java、C# 和 Ruby 这样的面向对象语言中，方法在类的上下文中被定义和继承：在一个对象上调用方法时，运行时会检测类以及它的超类中是否有此方法的定义，如果没有会导致异常发生。
      - 在 Go 语言中，这样的继承层次是完全没必要的：如果方法在此类型定义了，就可以调用它，和其他类型上是否存在这个方法没有关系。在这个意义上，Go 具有更大的灵活性。
      - Go 不需要一个显式的类定义，如同 Java、C++、C# 等那样，相反地，“类”是通过提供一组作用于一个共同类型的方法集来隐式定义的。类型可以是结构体或者任何用户自定义类型。
      - 在 Java 或 C# 中，这个方法需要和类 Integer 的定义放在一起，在 Ruby 中可以直接在基本类型 int 上定义这个方法。
      - 总结
        - 在 Go 中，类型就是类（数据和关联的方法）。Go 不知道类似面向对象语言的类继承的概念。继承有两个好处：代码复用和多态。
        - 在 Go 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 组件编程 (Component Programming)。
        - 许多开发者说相比于类继承，Go 的接口提供了更强大、却更简单的多态行为。
      - 备注
        - 如果真的需要更多面向对象的能力，看一下 goop 包 (Go Object-Oriented Programming)，它由 Scott Pakin 编写: 它给 Go 提供了 JavaScript 风格的对象（基于原型的对象），并且支持多重继承和类型独立分派，通过它可以实现你喜欢的其他编程语言里的一些结构。

6. 类型的 String() 方法和格式化描述符

   - 当定义了一个有很多方法的类型时，十之八九你会使用 `String()` 方法来定制类型的字符串形式的输出，换句话说：一种可阅读性和打印性的输出。
   - 如果类型定义了 `String()` 方法，它会被用在 `fmt.Printf()` 中生成默认的输出：等同于使用格式化描述符 %v 产生的输出。还有 `fmt.Print()` 和 `fmt.Println()` 也会自动使用 `String()` 方法。
   - 当广泛使用一个自定义类型时，最好为它定义 `String()` 方法。
   - 格式化描述符 `%T` 会给出类型的完全规格，`%#v` 会给出实例的完整输出，包括它的字段（在程序自动生成 Go 代码时也很有用）。
   - 不要在 `String()` 方法里面调用涉及 `String()` 方法的方法，它会导致意料之外的错误，比如下面的例子，它导致了一个无限递归调用（`TT.String()` 调用 `fmt.Sprintf`，而 `fmt.Sprintf` 又会反过来调用 `TT.String()`），很快就会导致内存溢出：

     ```
       type TT float64

       func (t TT) String() string {
           return fmt.Sprintf("%v", t)
       }
       t.String()
     ```
   - 
