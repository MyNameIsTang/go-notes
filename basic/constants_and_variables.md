## 常量

- 常量使用关键字 const 定义，用于存储不会改变的数据。
- 存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。
- 常量的定义格式：const identifier [type] = value，例如：`const Pi = 3.14159`。在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。
  - 显示类型定义：`const b string = "abc"`
  - 隐式类型定义： `const b = "abc"`
- 一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。
  ```
    var n int
    f(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int
  ```
- 常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。
- 编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。
- 数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出：
  ```
    const Ln2 = 0.693147180559945309417232121458\
  		176568075500134360255254120680009
    const Log2E = 1/Ln2 // this is a precise reciprocal
    const Billion = 1e9 // float constant
    const hardEight = (1 << 100) >> 97
  ```
- 反斜杠 \ 可以在常量表达式中作为多行的连接符使用。
- 与各种类型的数字型变量相比，你无需担心常量之间的类型转换问题，因为它们都是非常理想的数字。
- 当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间就引发错误。
- 常量也允许使用并行赋值的形式，常量还可以用作枚举：
  ```
    const beef, two, c = "eat", 2, "veg"
    const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6
    const (
      Monday, Tuesday, Wednesday = 1, 2, 3
      Thursday, Friday, Saturday = 4, 5, 6
    )
  ```
- 常量之所以为常量就是恒定不变的量，因此我们无法在程序运行过程中修改它的值；如果你在代码中试图修改常量的值则会引发编译错误。

## 变量

1. 简介

- 声明变量的一般形式是使用 var 关键字：`var identifier type`。
- Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。
  - 首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：`int* a, b;`。
  - 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。
- 因式分解关键字的写法一般用于声明全局变量。
  ```
    var (
      a int
      b bool
      str string
    )
  ```
- 当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float32(64) 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。
- 变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：`numShips 和 startDate`。但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。
- 作用域：
  - 一个变量（常量、类型或函数）在程序中都有一定的作用范围
  - 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。
    ```
      var n int64 = 2
      <!-- 或者 -->
      a := 1
    ```
  - 如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。
    ```
      var (
        HOME = os.Getenv("HOME")
        USER = os.Getenv("USER")
        GOROOT = os.Getenv("GOROOT")
      )
    ```
  - 尽管变量的标识符必须是唯一的，但你可以在某个代码块的内层代码块中使用相同名称的变量，则此时外部的同名变量将会暂时隐藏（结束内部代码块的执行后隐藏的外部同名变量又会出现，而内部同名变量则被释放），你任何的操作都只会影响内部代码块的局部变量。
- 变量可以编译期间就被赋值，赋值给变量使用运算符等号 =，当然你也可以在运行时对变量进行赋值操作。
- 声明与赋值（初始化）语句也可以组合起来，例如：`var identifier [type] = value`。但是 Go 编译器的智商已经高到可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在编译时就已经完成推断过程。
- 不过自动推断类型并不是任何时候都适用的，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型，例如：`var n int64 = 2`。
- 变量的类型也可以在运行时实现自动推断，例如：`var HOME = os.Getenv("HOME")`

```
  package main

  import (
    "fmt"
    "runtime"
    "os"
  )

  func main() {
    var goos string = runtime.GOOS
    fmt.Printf("The operating system is: %s\n", goos)
    path := os.Getenv("PATH")
    fmt.Printf("Path is %s\n", path)
  }
```

2. 值类型和引用类型

- 根据不同的处理器以及操作系统类型，所有的字都具有 32 位（4 字节）或 64 位（8 字节）的相同长度；所有的字都使用相关的内存地址来进行表示（以十六进制数表示）。
- 内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。
- 基本类型

  - 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。像树组和结构这些复合类型也是值类型。
  - 当使用等号 = 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝。
  - 你可以通过 &i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。

- 引用类型
  - 更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。这个内存地址被称之为指针，这个指针实际上也被存在另外的某一个字中。
  - 同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。
  - 在 Go 语言中，指针属于引用类型，其它的引用类型还包括 slices，maps 和 channel。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。

3. 打印

- 函数 Printf 可以在 fmt 包外部使用，这是因为它以大写字母 P 开头，该函数主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数：`func Printf(format string, list of variables to be printed)`。
- 格式化字符串可以含有一个或多个的格式化标识符，例如：%..，其中 .. 可以被不同类型所对应的标识符替换。
  - %s 代表字符串标识符。
  - %v 代表使用类型的默认输出格式的标识符。
  - %t 代表布尔型标识符。
  - %d 用于格式化整数。
  - %x 和 %X 用于格式化 16 进制表示的数字。
  - %g 用于格式化浮点型。
  - %f 输出浮点数。
  - %e 输出科学计数表示法。
  - %0nd 用于规定输出长度为 n 的整数，其中开头的数字 0 是必须的。
  - %n.mg 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 %5.2e 来输出 3.4 的结果为 3.40e+00。
  - %b 是用于表示位的格式化标识符。
- 标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加，如果参数超过 1 个则同样需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。
- 函数 fmt.Sprintf 与 Printf 的作用是完全相同的，不过前者将格式化后的字符串以返回值的形式返回给调用者，因此你可以在程序中使用包含变量的字符串。
- 函数 fmt.Print 和 fmt.Println 会自动使用格式化标识符 %v 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。

4. 简短形式，使用:=赋值操作符

- 这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。
- 注意事项：
  - 如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明。
  - 如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。
  - 声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误。
  - 全局变量是允许声明但不使用。
- 其他简短形式：
  - 同一类型的多个变量可以声明在同一行，并行 或 同时 赋值。
    ```
      var a, b, c int
      <!-- 或者 -->
      a, b, c := 5, 7, "abc"
    ```
  - 多变量可以在同一行进行赋值。
    ```
      a, b, c = 5, 7, "abc"
    ```
  - 空白标识符 _ 也被用于抛弃值，如值 5 在：`_, b = 5, 7` 中被抛弃。
  - 并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：`val, err = Func1(var1)`。

5. init 函数

- 变量除了可以在全局声明中初始化，也可以在 init() 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main() 函数高。
- 每个源文件可以包含多个 init() 函数，同一个源文件中的 init() 函数会按照从上到下的顺序执行，如果一个包有多个源文件包含 init() 函数的话，则官方鼓励但不保证以文件名的顺序调用。初始化总是以单线程并且按照包的依赖关系顺序执行。
- 一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。
- init() 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine
  ```
    func init() {
      // setup preparations
      go backend()
    }
  ```
