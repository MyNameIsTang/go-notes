## 数组与切片

- 集合，它是可以包含大量条目 (item) 的数据结构，例如数组、切片和 map。从这看到 Go 明显受到 Python 的影响。
- 以 [] 符号标识的数组类型几乎在所有的编程语言中都是一个基本主力。Go 语言中的数组也是类似的，只是有一些特点。
- Go 没有 C 那么灵活，但是拥有切片 (slice) 类型。这是一种建立在 Go 语言数组类型之上的抽象，要想理解切片我们必须先理解数组。
- 数组有特定的用处，但是却有一些呆板，所以在 Go 语言的代码里并不是特别常见。相对的，切片确实随处可见的。它们构建在数组之上并且提供更强大的能力和便捷。

1. 声明和初始化

   1. 概念
      - 数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列（这是一种同构的数据结构）。
      - 这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。
      - 数组长度必须是一个常量表达式，并且必须是一个非负整数。数组长度也是数组类型的一部分，所以 [5]int 和 [10]int 是属于不同类型的。
      - 数组的编译时值初始化是按照数组顺序完成的。
      - 想让数组元素类型为任意类型的话可以使用空接口作为类型。当使用值时我们必须先做一个类型判断。
      - 数组元素可以通过 索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推（数组以 0 开始在所有类 C 语言中是相似的）。元素的数目（也称为长度或者数组大小）必须是固定的并且在声明该数组时就给出（编译时需要知道数组长度以便分配内存）；数组长度最大为 2GB。
      - 声明的格式：`var identifier [len]type`。
      - 对索引项为 i 的数组元素赋值可以这么操作：`arr[i] = value`，所以数组是 可变的。
      - 只有有效的索引可以被使用，当使用等于或者大于 len(arr1) 的索引时：如果编译器可以检测到，会给出索引超限的提示信息；如果检测不到的话编译会通过而运行时会 panic()。
      - 由于索引的存在，遍历数组的方法自然就是使用 for 结构：
        - 通过 for 初始化数组项
        - 通过 for 打印数组元素
        - 通过 for 依次处理元素
      ```
         for i:=0; i < len(arr1); i++｛
           arr1[i] = ...
         }
      ```
      ```
        for i,_:= range arr1 {
        ...
        }
      ```
      - Go 语言中的数组是一种 值类型（不像 C/C++ 中是指向首元素的指针），所以可以通过 new() 来创建：`var arr1 = new([5]int)`。这种方式和 `var arr2 [5]int` 的区别是什么呢？arr1 的类型是 `*[5]int`，而 arr2 的类型是 `[5]int`。
   2. 数组常量
      - 如果数组值已经提前知道了，那么可以通过 数组常量 的方法来初始化数组，而不用依次使用 `[]=` 方法（所有的组成元素都有相同的常量语法）。
        ```
          var arrKeyValue = [5]string{3: "Chris", 4: "Ron"}
        ```
      - 第一种：`var arrAge = [10]int {1, 2, 3}`，这是一个有 10 个元素的数组，除了前三个元素外其他元素都为 0。
      - 第二种：`var arrLazy = [...]int{5, 6, 7, 8, 22}`，... 同样可以忽略，从技术上说它们其实变成了切片。
      - 第三种：key: value 语法，`var arrKeyValue = [5]string{3: "Chris", 4: "Ron"}`。
      - 可以取任意数组常量的地址来作为指向新实例的指针。
        ```
          func fp(a *[3]int) { fmt.Println(a) }
          func main() {
            for i := 0; i < 3; i++ {
              fp(&[3]int{i, i * i, i * i * i})
            }
          }
        ```
      - 几何点（或者数学向量）是一个使用数组的经典例子。为了简化代码通常使用一个别名：
        ```
          type Vector3D [3]float32
          var vec Vector3D
        ```
   3. 多维数组

      - 数组通常是一维的，但是可以用来组装成多维数组，例如：`[3][5]int`，`[2][2][2]float64`。
      - 内部数组总是长度相同的。Go 语言的多维数组是矩形式的，唯一的例外是切片的数组。

        ```
          const (
            WIDTH  = 1920
            HEIGHT = 1080
          )

          var screen [WIDTH][HEIGHT]int

          for i := 0; i < HEIGHT; i++ {
            for j := 0; j < WIDTH; j++ {
              screen[j][i] = 0
            }
          }
        ```

   4. 将数组传递给函数
      - 把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种情况：
        - 传递数组的指针
        - 使用数组的切片

2. 切片

   - 概念
     - 切片 (slice) 是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。
     - 切片是可索引的，并且可以由 `len()` 函数获取长度。
     - 给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0， 最大为相关数组的长度：切片是一个 长度可变的数组。
     - 切片提供了计算容量的函数 `cap()` 可以测量切片最长可以达到多少：它等于切片的长度 + 数组除切片之外的长度。如果 s 是一个切片，`cap(s)` 就是从 `s[0]` 到数组末尾的数组长度。切片的长度永远不会超过它的容量，所以对于切片 s 来说该不等式永远成立：`0 <= len(s) <= cap(s)`。
     - 多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。
     - 优点 因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中切片比数组更常用。
     - 声明切片的格式是： `var identifier []type`（不需要说明长度）。一个切片在未初始化之前默认为 nil，长度为 0。
     - 切片的初始化格式是：`var slice1 []type = arr1[start:end]`。
       - 这表示 slice1 是由数组 arr1 从 start 索引到 end-1 索引之间的元素构成的子集（切分数组，start:end 被称为切片表达式）。所以 `slice1[0]` 就等于 `arr1[start]`。这可以在 arr1 被填充前就定义好。
       - `var slice1 []type = arr1[:]` 那么 slice1 就等于完整的 arr1 数组（所以这种表示方式是 `arr1[0:len(arr1)]` 的一种缩写）。另外一种表述方式是：`slice1 = &arr1`。
       - `arr1[2:]` 和 `arr1[2:len(arr1)]` 相同，都包含了数组从第三个到最后的所有元素。
       - `arr1[:3]` 和 `arr1[0:3]` 相同，包含了从第一个到第三个元素（不包括第四个）。
       - 如果想去掉 slice1 的最后一个元素，只要 `slice1 = slice1[:len(slice1)-1]`。
     - 用切片组成的切片，拥有相同的元素，仍然指向相同的相关数组。
     - 一个切片 s 可以这样扩展到它的大小上限：`s = s[:cap(s)]`，如果再扩大的话就会导致运行时错误。
     - 对于每一个切片（包括 string），以下状态总是成立的：
       ```
         s == s[:i] + s[i:] // i是一个整数且: 0 <= i <= len(s)
         len(s) <= cap(s)
       ```
     - 切片也可以用类似数组的方式初始化：`var x = []int{2, 3, 5, 7, 11}`。这样就创建了一个长度为 5 的数组并且创建了一个相关切片。
     - 切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片长度以及切片容量。
     - 如果 s2 是一个切片，你可以将 s2 向后移动一位 `s2 = s2[1:]`，但是末尾没有移动。切片只能向后移动，`s2 = s2[-1:]` 会导致编译错误。切片不能被重新分片以获取数组的前一个元素。
     - 注意 绝对不要用指针指向切片。切片本身已经是一个引用类型，所以它本身就是一个指针！！。
   - 将切片传递给函数

     - 如果有一个函数需要对数组做操作，可能总是需要把参数声明为切片。当调用该函数时，把数组分片，创建为一个切片引用并传递给该函数。这里有一个计算数组元素和的方法:

       ```
         func sum(a []int) int {
           s := 0
           for i := 0; i < len(a); i++ {
             s += a[i]
           }
           return s
         }

         func main() {
           var arr = [5]int{0, 1, 2, 3, 4}
           sum(arr[:])
         }
       ```

   - 用 make() 创建一个切片
     - 当相关数组还没有定义时，我们可以使用 `make()` 函数来创建一个切片，同时创建好相关数组：`var slice1 []type = make([]type, len)`。也可以简写为 `slice1 := make([]type, len)`，这里 len 是数组的长度并且也是 slice 的初始长度。
     - `make()` 接受 2 个参数：元素的类型以及切片的元素个数。
     - `make()` 的使用方式是：`func make([]T, len, cap)`，其中 cap 是可选参数。
     - 下面两种方法可以生成相同的切片:
       ```
         make([]int, 50, 100)
         new([100]int)[0:50]
       ```
     - 因为字符串是纯粹不可变的字节数组，它们也可以被切分成切片。
   - new() 和 make() 的区别
     - 看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。
       - new(T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 \*T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &T{}。
       - make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel。
     - 换言之，new() 函数分配内存，make() 函数初始化；下图给出了区别：
       ![区别](./image/function_fig7.3.png)
   - 如何理解 new、make、slice、map、channel 的关系
     - slice、map 以及 channel 都是 golang 内建的一种引用类型，三者在内存中存在多个组成部分， 需要对内存组成部分初始化后才能使用，而 make 就是对三者进行初始化的一种操作方式
     - new 获取的是存储指定变量内存地址的一个变量，对于变量内部结构并不会执行相应的初始化操作， 所以 slice、map、channel 需要 make 进行初始化并获取对应的内存地址，而非 new 简单的获取内存地址
